#define __USE_MISC 1

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <complex.h>
#include <time.h>

typedef struct {
    complex *value;
} qubit;

qubit * qubit_init() {
    unsigned long u, m = ~(1 << 31);
    double tmp;
    qubit *q = (qubit *) calloc(1, sizeof(qubit));
    if (q) {
        q->value = (complex *) calloc(2, sizeof(complex));
        if (q->value) {
            u = rand() & m;
            tmp = ldexp((double) u, -30) * M_PI;
            /* Setting random zero ket */
            q->value[0] = CMPLX(sin(tmp), cos(tmp));
            q->value[1] = CMPLX(0.0, 0.0);
        }
    }
    return q;
}

void qubit_free(qubit *q) {
    free(q->value);
    free(q);
}

void quantum_not(qubit *q) {
    complex a;
    if (q) if (q->value) {
        a = q->value[0];    
        q->value[0] = q->value[1];
        q->value[1] = a;
    }
}

void pauli_identity(qubit *q) {
    return;
}

void pauli_X(qubit *q) {
    if (q) if (q->value) {
        quantum_not(q);
    }
}

void pauli_Y(qubit *q) {
    complex a;
    if (q) if (q->value) {
        a = q->value[0] * CMPLX(0.0, 1.0);
        q->value[0] = q->value[1] * CMPLX(0.0, -1.0);
        q->value[1] = a;
    }
}

void pauli_Z(qubit *q) {
    if (q) if (q->value) {
        q->value[1] = -q->value[1];
    }
}

void sqrt_not(qubit *q) {
    complex a, b;
    if (q) if (q->value) {
        a = CMPLX(0.5, 0.5) * q->value[0] + CMPLX(0.5, -0.5) * q->value[1];
        b = CMPLX(0.5, -0.5) * q->value[0] - CMPLX(0.5, 0.5) * q->value[1];
        q->value[0] = a;
        q->value[1] = b;
    }
}

void hadamard(qubit *q) {
    complex a, b;
    double const m_isqrt2 = sqrt(0.5);
    if (q) if (q->value) {
        a = (q->value[0] + q->value[1]) * m_isqrt2;
        b = (q->value[0] - q->value[1]) * m_isqrt2;
        q->value[0] = a;
        q->value[1] = b;
    }
}

void r_x(qubit *q, double alpha) {
    complex a, b;
    double const c = cos(alpha * 0.5);
    double const s = sin(alpha * 0.5);
    if (q) if (q->value) {
        a = c * q->value[0] - CMPLX(0.0, s) * q->value[1];
        b = CMPLX(0.0, -s) * q->value[0] + c * q->value[1];
        q->value[0] = a;
        q->value[1] = b;
    }
}

void r_y(qubit *q, double alpha) {
    complex a, b;
    double const c = cos(alpha * 0.5);
    double const s = sin(alpha * 0.5);
    if (q) if (q->value) {
    a = c * q->value[0] - s * q->value[1];
    b = s * q->value[0] + c * q->value[1];
    q->value[0] = a;
    q->value[1] = b;
    }
}

void r_z(qubit *q, double alpha) {
    double const am = alpha * 0.5;
    if (q) if (q->value) {
        q->value[0] *= cexp(CMPLX(0.0, -am));
        q->value[1] *= cexp(CMPLX(0.0, am));
    }
}

void phase_shift(qubit *q, double delta) {
    complex const eid = cexp(CMPLX(0.0, delta));
    if (q) if (q->value) {
        q->value[0] *= eid;
        q->value[1] *= eid;
    }
}

char observe_qubit(qubit *q) {
    unsigned long u, m = ~(1 << 31);
    double tmp;
    char res = 0;

    if (q) if (q->value) {
        tmp = cabs(q->value[1]);
        u = rand() & m;
        tmp *= tmp;
#ifdef _DEBUG
        printf("\nDEBUG tmp = %f\n", tmp);
#endif
        res = (char) (ldexp((double) u, -31) <= tmp);
    }

    return res;
    
}

double qubit_expectation(qubit *q) {
    double res = cabs(q->value[1]);
    return res * res;
}

/* Test function */
int main() {
    int i;
    qubit *q;
    
    srand(time(NULL)); /* Initialize the random generator */
    q = qubit_init(); /* Initialize the qubit */

    printf("Theoretical quantum state initially stored in memory:\n");
    printf("(%f%s%fi, %f%s%fi)\n\n",
           creal(q->value[0]), 
           cimag(q->value[0]) >= 0.0 ? "+" :"", 
           cimag(q->value[0]), 
           creal(q->value[1]), 
           cimag(q->value[1]) >= 0.0 ? "+" :"",
           cimag(q->value[1]));

    /* Applying quantum gates to obtain final superposition */
    pauli_identity(q);
    hadamard(q);
    pauli_X(q);
    phase_shift(q, 3.0 * M_PI_4);
    pauli_Y(q);
    r_x(q, M_PI_2 * 3);
    pauli_Z(q);
    r_y(q, M_PI * 0.123);
    sqrt_not(q);
    r_z(q, -0.321 * M_PI_2);
    quantum_not(q);
    hadamard(q);

    printf("Final superposition stored in memory:\n");
    printf("(%f%s%fi, %f%s%fi)\n\n",
           creal(q->value[0]), 
           cimag(q->value[0]) >= 0.0 ? "+" :"", 
           cimag(q->value[0]), 
           creal(q->value[1]), 
           cimag(q->value[1]) >= 0.0 ? "+" :"",
           cimag(q->value[1]));

    printf("Theorical expectation of the observed qubit status: %f\n",
           qubit_expectation(q));

    printf("Observations generated by accessing the status of the qubit:\n");
    for (i = 1; i <= 40; i++) {
        printf("\t%d", observe_qubit(q));
        if (i % 5 == 0) printf("\n");
    }

    qubit_free(q);
    return 0;
}
